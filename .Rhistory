test$Outstate - preds
length(preds)
length(test$Outstate)
mean(test$Outstate - preds)
TSS = sum( (test$Outstate - mean(test$Outstate))^2 )
RSS = sum( (res-mean(res))^2 )
r2 = 1 - RSS/TSS
r2
TSS = sum( (test$Outstate - mean(test$Outstate))^2 )
RSS = sum( res^2 )
r2 = 1 - RSS/TSS
r2
# ------------------------ (d) ------------------------
summary(fit)
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
x = mvrnorm(n, mu=integer(k), Sigma=diag(k))
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k), Sigma=diag(k))
Y = rowsum(X)
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k), Sigma=diag(k))
Y = rowSum(X)
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k), Sigma=diag(k))
Y = rowSums(X)
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
Y = rowSums(X)
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
Y = rowSums(X)
colnames(X)
X$x1
X[, 'x1']
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
Y = 3*X[, 'x1'] + 5*X[, 'x2']
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
fit = lm(y.1~x2)
summary(fit)
coef(fit)
coef(fit)[, 'x2']
class( coef(fit) )
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
fit.1 = lm(y.1~x2)
summary(fit.1)
# ------------------------ (d) ------------------------
b2 = coef(fit.1)[2]
y.2 = Y - b2 * x2
fit.2 = lm(y.2~x1)
summary(fit.2)
fit$coef
fit.1$coefficients
# ------------------------ (e) ------------------------
n.loop = 1000
b0.vec = rep(0, n.loop)
b1.vec = rep(0, n.loop)
b2.vec = rep(0, n.loop)
# initialize
b1 = 0
y.1 = y - b1 * x1
fit.1 = lm(y.1~x2)
b2.vec[1] = fit$coefficient[2]
for(i in 2:n.loop){
y.2 = y - b2.vec[i-1]*x2
fit.2 = lm(y.2~x1)
b1.vec[i] = fit.2$coefficients[2]
y.1 = y - b1.vec[i] * x1
fit.1 = lm(y.1~x2)
b2.vec[i] = fit.1$coefficients[2]
}
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
fit.1 = lm(y.1~x2)
summary(fit.1)
# ------------------------ (d) ------------------------
b2 = coef(fit.1)[2]
y.2 = Y - b2 * x2
fit.2 = lm(y.2~x1)
summary(fit.2)
# ------------------------ (e) ------------------------
n.loop = 1000
b0.vec = rep(0, n.loop)
b1.vec = rep(0, n.loop)
b2.vec = rep(0, n.loop)
# initialize
b1 = 0
y.1 = y - b1 * x1
fit.1 = lm(y.1~x2)
b2.vec[1] = fit.1$coefficients[2]
b0.vec[1] = fit.1$coefficients[1]
for(i in 2:n.loop){
y.2 = Y - b2.vec[i-1]*x2
fit.2 = lm(y.2~x1)
b1.vec[i] = fit.2$coefficients[2]
y.1 = Y - b1.vec[i] * x1
fit.1 = lm(y.1~x2)
b2.vec[i] = fit.1$coefficients[2]
b0.vec[i] = fit.1$coefficients[1]
}
plot(1:n.loop, b0.vec, type='l', col='grey', xlab='beta', ylab='value', lwd=2)
lines(1:n.loop, b1.vec, col='blue', lwd=2)
lines(1:n.loop, b2.vec, col='red', lwd=2)
legend('topright', legend=c('beta0', 'beta1', 'beta2'), col=c('grey', 'blue', 'red'), lwd=1)
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
fit.1 = lm(y.1~x2)
summary(fit.1)
# ------------------------ (d) ------------------------
b2 = coef(fit.1)[2]
y.2 = Y - b2 * x2
fit.2 = lm(y.2~x1)
summary(fit.2)
# ------------------------ (e) ------------------------
n.loop = 1000
b0.vec = rep(0, n.loop)
b1.vec = rep(0, n.loop)
b2.vec = rep(0, n.loop)
# initialize
b1 = 0
y.1 = Y - b1 * x1
fit.1 = lm(y.1~x2)
b2.vec[1] = fit.1$coefficients[2]
b0.vec[1] = fit.1$coefficients[1]
for(i in 2:n.loop){
y.2 = Y - b2.vec[i-1]*x2
fit.2 = lm(y.2~x1)
b1.vec[i] = fit.2$coefficients[2]
y.1 = Y - b1.vec[i] * x1
fit.1 = lm(y.1~x2)
b2.vec[i] = fit.1$coefficients[2]
b0.vec[i] = fit.1$coefficients[1]
}
plot(1:n.loop, b0.vec, type='l', col='grey', xlab='beta', ylab='value', lwd=2)
lines(1:n.loop, b1.vec, col='blue', lwd=2)
lines(1:n.loop, b2.vec, col='red', lwd=2)
legend('topright', legend=c('beta0', 'beta1', 'beta2'), col=c('grey', 'blue', 'red'), lwd=1)
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
fit.1 = lm(y.1~x2)
summary(fit.1)
# ------------------------ (d) ------------------------
b2 = coef(fit.1)[2]
y.2 = Y - b2 * x2
fit.2 = lm(y.2~x1)
summary(fit.2)
# ------------------------ (e) ------------------------
n.loop = 1000
b0.vec = rep(0, n.loop)
b1.vec = rep(0, n.loop)
b2.vec = rep(0, n.loop)
# initialize
b1 = 0
y.1 = Y - b1 * x1
fit.1 = lm(y.1~x2)
b2.vec[1] = fit.1$coefficients[2]
b0.vec[1] = fit.1$coefficients[1]
for(i in 2:n.loop){
y.2 = Y - b2.vec[i-1]*x2
fit.2 = lm(y.2~x1)
b1.vec[i] = fit.2$coefficients[2]
y.1 = Y - b1.vec[i] * x1
fit.1 = lm(y.1~x2)
b2.vec[i] = fit.1$coefficients[2]
b0.vec[i] = fit.1$coefficients[1]
}
plot(1:n.loop, b0.vec, type='l', col='grey', lwd=2,
xlim=c(1, n.loop), ylim=c(-1, 10), xlab='beta', ylab='value')
lines(1:n.loop, b1.vec, col='blue', lwd=2)
lines(1:n.loop, b2.vec, col='red', lwd=2)
legend('topright', legend=c('beta0', 'beta1', 'beta2'), col=c('grey', 'blue', 'red'), lwd=1)
# ------------------------ (f) ------------------------
fit = lm(Y~x1+x2)
abline(h=fit$coefficients[1], lty=2, col='grey')
abline(h=fit$coefficients[2], lty=2, col='blue')
abline(h=fit$coefficients[3], lty=2, col='red')
fit$coefficients
# ------------------------ (g) ------------------------
sum.fit = summary(fit)
sum.fit
b2.vec[n.loop]
coef(sum.fit)
coef(sum.fit)[, 2]
sum.fit = summary(fit)
b0 = fit$coefficients[1]
b1 = fit$coefficients[2]
b2 = fit$coefficients[3]
fit.se = coef(sum.fit)[, 2]
b0.se = fit.se[1]
b1.se = fit.se[2]
b2.se = fit.se[3]
which(abs(b0.vec - b0) < 2*b0.se)
length( which(abs(b0.vec - b0) < 2*b0.se) )
idx.b0 = min(which(abs(b0.vec - b0) < 2*b0.se))
idx.b1 = min(which(abs(b1.vec - b1) < 2*b1.se))
idx.b2 = min(which(abs(b2.vec - b2) < 2*b2.se))
idx = max(idx.b0, idx.b1, idx.b2)
b1
b2
b1.se
b2.se
min(which(abs(b1.vec - b1) < 2*b1.se))
which(abs(b1.vec - b1) < 2*b1.se)
abs(b1.vec - b1) < 2*b1.se
b1
b1.se
b1[1000]
b1.vec
b1.vec
b1.vec[1000]-b1
abs(b1.vec[1000]-b1)
abs(b1.vec[1000]-b1)<2*b1.se
b1.se
b1.vec[1000]
b1.vec[1000]-b1
library(MASS)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
fit.1 = lm(y.1~x2)
summary(fit.1)
# ------------------------ (d) ------------------------
b2 = coef(fit.1)[2]
y.2 = Y - b2 * x2
fit.2 = lm(y.2~x1)
summary(fit.2)
# ------------------------ (e) ------------------------
n.loop = 1000
b0.vec = rep(0, n.loop)
b1.vec = rep(0, n.loop)
b2.vec = rep(0, n.loop)
# initialize
b1 = 0
y.1 = Y - b1 * x1
fit.1 = lm(y.1~x2)
b2.vec[1] = fit.1$coefficients[2]
b0.vec[1] = fit.1$coefficients[1]
for(i in 2:n.loop){
y.2 = Y - b2.vec[i-1]*x2
fit.2 = lm(y.2~x1)
b1.vec[i] = fit.2$coefficients[2]
y.1 = Y - b1.vec[i] * x1
fit.1 = lm(y.1~x2)
b2.vec[i] = fit.1$coefficients[2]
b0.vec[i] = fit.1$coefficients[1]
}
plot(1:n.loop, b0.vec, type='l', col='grey', lwd=2,
xlim=c(1, n.loop), ylim=c(-1, 10), xlab='beta', ylab='value')
lines(1:n.loop, b1.vec, col='blue', lwd=2)
lines(1:n.loop, b2.vec, col='red', lwd=2)
legend('topright', legend=c('beta0', 'beta1', 'beta2'), col=c('grey', 'blue', 'red'), lwd=1)
# ------------------------ (f) ------------------------
fit = lm(Y~x1+x2)
abline(h=fit$coefficients[1], lty=2, col='grey')
abline(h=fit$coefficients[2], lty=2, col='blue')
abline(h=fit$coefficients[3], lty=2, col='red')
# The dashed lines are coefficients obtained from directly regressing
# Y on x1 and x2
# They are overlapping with previous results
# ------------------------ (g) ------------------------
sum.fit = summary(fit)
b0 = fit$coefficients[1]
b1 = fit$coefficients[2]
b2 = fit$coefficients[3]
fit.se = coef(sum.fit)[, 2]
b0.se = fit.se[1]
b1.se = fit.se[2]
b2.se = fit.se[3]
idx.b0 = min(which(abs(b0.vec - b0) < 2*b0.se))
idx.b1 = min(which(abs(b1.vec - b1) < 2*b1.se))
idx.b2 = min(which(abs(b2.vec - b2) < 2*b2.se))
idx = max(idx.b0, idx.b1, idx.b2)
min(which(abs(b0.vec - b0) < 2*b0.se))
which(abs(b1.vec - b1) < 2*b1.se)
abs(b1.vec - b1) < 2*b1.se
idx
idx.b1
idx.b0
library(MASS)
set.seed(1)
# ------------------------ (a) ------------------------
n = 100
k = 2
X = mvrnorm(n, mu=integer(k+1), Sigma=diag(k+1))
colnames(X) = c(paste0('x', 1:k), 'eps')
x1 = X[, 'x1']
x2 = X[, 'x2']
Y = 3*x1 + 5*x2
# ------------------------ (b) ------------------------
b1 = 0.5
# ------------------------ (c) ------------------------
y.1 = Y-b1*x1
fit.1 = lm(y.1~x2)
summary(fit.1)
# ------------------------ (d) ------------------------
b2 = coef(fit.1)[2]
y.2 = Y - b2 * x2
fit.2 = lm(y.2~x1)
summary(fit.2)
# ------------------------ (e) ------------------------
n.loop = 1000
b0.vec = rep(0, n.loop)
b1.vec = rep(0, n.loop)
b2.vec = rep(0, n.loop)
# initialize
b1 = 0
y.1 = Y - b1 * x1
fit.1 = lm(y.1~x2)
b2.vec[1] = fit.1$coefficients[2]
b0.vec[1] = fit.1$coefficients[1]
for(i in 2:n.loop){
y.2 = Y - b2.vec[i-1]*x2
fit.2 = lm(y.2~x1)
b1.vec[i] = fit.2$coefficients[2]
y.1 = Y - b1.vec[i] * x1
fit.1 = lm(y.1~x2)
b2.vec[i] = fit.1$coefficients[2]
b0.vec[i] = fit.1$coefficients[1]
}
plot(1:n.loop, b0.vec, type='l', col='grey', lwd=2,
xlim=c(1, n.loop), ylim=c(-1, 10), xlab='beta', ylab='value')
lines(1:n.loop, b1.vec, col='blue', lwd=2)
lines(1:n.loop, b2.vec, col='red', lwd=2)
legend('topright', legend=c('beta0', 'beta1', 'beta2'), col=c('grey', 'blue', 'red'), lwd=1)
# ------------------------ (f) ------------------------
fit = lm(Y~x1+x2)
abline(h=fit$coefficients[1], lty=2, col='grey')
abline(h=fit$coefficients[2], lty=2, col='blue')
abline(h=fit$coefficients[3], lty=2, col='red')
# The dashed lines are coefficients obtained from directly regressing
# Y on x1 and x2
# They are overlapping with previous results
# ------------------------ (g) ------------------------
sum.fit = summary(fit)
b0 = fit$coefficients[1]
b1 = fit$coefficients[2]
b2 = fit$coefficients[3]
fit.se = coef(sum.fit)[, 2]
b0.se = fit.se[1]
b1.se = fit.se[2]
b2.se = fit.se[3]
idx.b0 = min(which(abs(b0.vec - b0) < 2*b0.se))
idx.b0
library(MASS)
set.seed(1)
# create variables
n = 1e5
p = 100
X = mvrnorm(n, mu=integer(p), Sigma=diag(p))
Y = X %*% c(1:p)
dim(X)
b.mat = matrix(0, nrow=p, ncol=n.loop)
n.loop = 1000
b.mat = matrix(0, nrow=p, ncol=n.loop)
y = Y - X[, 2:p] %*% beta[2:p, 1]
y = Y - X[, 2:p] %*% b.mat[2:p, 1]
r = 1
y = Y - X[, -r] %*% c(1:p)[-r]
y
fit = lm(y~X[, 1])
fit$coefficients
library(MASS)
set.seed(1)
# create variables
n = 1e5
p = 100
X = mvrnorm(n, mu=integer(p), Sigma=diag(p))
Y = X %*% c(1:p)
n.loop = 1000
b.mat = matrix(0, nrow=p, ncol=n.loop)
rss.vec = rep(0, n.loop)
for(c in 2:n.loop){
for(r in 1:p){
y = Y - X[, -r] %*% c(1:p)[-r]
fit = lm(y~X[, r])
b.mat[r, c] = fit$coefficients[2]
}
res = Y - X %*% b.mat[, c]
rss.vec[c] = sum(res^2)
}
b.mat
library(MASS)
set.seed(1)
# create variables
n = 1e4
p = 100
X = mvrnorm(n, mu=integer(p), Sigma=diag(p))
Y = X %*% c(1:p)
n.loop = 10
b.mat = matrix(0, nrow=p, ncol=n.loop)
rss.vec = rep(0, n.loop)
for(c in 2:n.loop){
for(r in 1:p){
y = Y - X[, -r] %*% c(1:p)[-r]
fit = lm(y~X[, r])
b.mat[r, c] = fit$coefficients[2]
}
res = Y - X %*% b.mat[, c]
rss.vec[c] = sum(res^2)
}
plot(2:n.looprss.vec)
View(b.mat)
View(b.mat)
plot(2:n.loop, rss.vec, type='l', xlab='iteration', ylab='rss')
plot(1:n.loop, rss.vec, type='l', xlab='iteration', ylab='rss')
rss.vec[1] = sum(Y^2)
plot(1:n.loop, rss.vec, type='l', xlab='iteration', ylab='rss')
