glm.fit = glm(mpg~poly(horsepower, i), data=Auto)
cv.error[i] = cv.glm(Auto, glm.fit)$delta[1]
}
cv.error
set.seed(1)
cv.error.10 = rep(0, 10)
for (i in 1:10) {
glm.fit = glm(mpg~ploy(horsepower, i), data=Auto)
cv.error.10[i] = cv.glm(Auto, glm.fit, K=10)$delta[1]
}
set.seed(1)
cv.error.10 = rep(0, 10)
for (i in 1:10) {
glm.fit = glm(mpg~poly(horsepower, i), data=Auto)
cv.error.10[i] = cv.glm(Auto, glm.fit, K=10)$delta[1]
}
cv.error.10
Portfolio
names(Portfolio)
Portfolio$X[1:10]
Portfolio$Y[1:10]
?Portfolio
alpha.fn(data, index) {
X = data$X[index]
Y = data$Y[index]
return( (var(Y)-cov(X,Y))/(var(X)+var(Y)-2*cov(X, Y)) )
}
alpha.fn(Portfolio, 1:100)
alpha.fn(data, index) {
X = data$X[index]
Y = data$Y[index]
return( (var(Y)-cov(X,Y))/(var(X)+var(Y)-2*cov(X, Y)) )
}
alpha.fn = function(data, index) {
X = data$X[index]
Y = data$Y[index]
return( (var(Y)-cov(X,Y))/(var(X)+var(Y)-2*cov(X, Y)) )
}
alpha.fn(Portfolio, 1:100)
alpha.fn(Portfolio, 1:100)
set.seed(1)
sample1 = sample(100, 100, replace=T)
alpha.fn(Portfolio, sample1)
dim(Portfolio)
boot(Portfolio, alpha.fn, R=1000)
boot.fn = function(data, index){
return( coef(lm(mpg~horsepower, data=data, subset=index)) )
}
boot.fn(Auto, 1:dim(Auto)[1])
set.seed(1)
sample1 = sample(n.obs, n.obs, replace=T)
boot.fn(Auto, sample1)
sample1 = sample(n.obs, n.obs, replace=T)
boot.fn(Auto, sample1)
boot(Auto, boot.fn, R=1000)
lm.fit = lm(mpg~horsepower, data=Auto)
summary(lm.fit)
boot.fn2 = function(data, index) {
return( coef(lm(mpg~poly(horsepower, 2), data=Auto)) )
}
boot(Auto, boot.fn2, R=1000)
lm.fit2 = lm(mpg~poly(horsepower,2), data=Auto)
summary(lm.fit2)
boot.fn2 = function(data, index) {
return( coef(lm(mpg~poly(horsepower, 2), data=Auto, subset=index)) )
}
boot(Auto, boot.fn2, R=1000)
lm.fit2 = lm(mpg~poly(horsepower,2), data=Auto)
summary(lm.fit2)
boot.fn2 = function(data, index) {
return( coef(lm(mpg~poly(horsepower, 2), data=Auto, subset=index)) )
}
set.seed(1)
boot(Auto, boot.fn2, R=1000)
lm.fit2 = lm(mpg~poly(horsepower,2), data=Auto)
summary(lm.fit2)
boot.fn2 = function(data, index) {
return( coef(lm(mpg~poly(horsepower, 2), data=data, subset=index)) )
}
set.seed(1)
boot(Auto, boot.fn2, R=1000)
poly(horsepower, 2)
lm.fit2 = lm(mpg~poly(horsepower,2), data=Auto)
summary(lm.fit2)
boot.fn2 = function(data, index) {
return( coef(lm(mpg~poly(horsepower, 2, raw=T), data=data, subset=index)) )
}
set.seed(1)
boot(Auto, boot.fn2, R=1000)
lm.fit2 = lm(mpg~poly(horsepower,2, raw=T), data=Auto)
summary(lm.fit2)
poly(1:10, 2)
poly(1:10, 2, raw=T)
# ************* Quetion 2 *************
# (g)
x = 1:1e5
y = 1 - (1-1/x)^x
y[100000]
plot(x, y)
plot(x, y, ylim=c(0, 1))
rec = rep(NA, 1e4)
for (i in 1:1e4){
rec[i] = sum(sample(100, replace=T) == 4) > 0
}
mean(rec[i])
set.seed(1)
rec = rep(NA, 1e4)
for (i in 1:1e4){
rec[i] = sum(sample(100, replace=T) == 4) > 0
}
mean(rec[i])
set.seed(1)
rec = rep(NA, 1e4)
for (i in 1:1e4){
rec[i] = sum(sample(1:100, replace=T) == 4) > 0
}
mean(rec[i])
set.seed(1)
rec = rep(NA, 1e4)
for (i in 1:1e4){
rec[i] = sum(sample(1:100, replace=T) == 4) > 0
}
mean(rec)
?Default
library(ISLR)
?Default
glm.fit = glm(default~income+balance, data=Default, family=binomial)
contrasts(default)
contrasts(Default$default)
set.seed(1)
n.obs = nrow(Default)
train = sample(n.obs, round(n.obs/2), replace=F)
glm.fit = glm(default~income+balance, data=Default, subset=train, family=binomial)
glm.prob = predict(glm.fit, Default[-train, ], type='response')
set.seed(1)
n.obs = nrow(Default)
train = sample(n.obs, round(n.obs/2), replace=F)
Default.train = Default[train, ]
Default.test = Default[-train, ]
glm.fit = glm(default~income+balance, data=Default.train, family=binomial)
glm.prob = predict(glm.fit, newdata=Default.test, type='response')
glm.pred = rep('No', nrow(Default.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
table(glm.pred, Default.test$default)
mean(glm.pred!=Default.test$default)
b.fn = function(data, index){
data.train = data[index, ]
data.test = data[-index, ]
glm.fit = glm(default~income+balance, data=data.train, family=binomial)
glm.prob = predict(glm.fit, newdata=data.test, type='response')
glm.pred = rep('No', nrow(data.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
table(glm.pred, data.test$default)
mean(glm.pred!=data.test$default)
}
set.seed(2)
n.obs = nrow(Default)
train2 = sample(n.obs, round(n.obs/2), replace=F)
b.fn(Default, train2)
b.fn = function(data, index){
data.train = data[index, ]
data.test = data[-index, ]
glm.fit = glm(default~income+balance, data=data.train, family=binomial)
glm.prob = predict(glm.fit, newdata=data.test, type='response')
glm.pred = rep('No', nrow(data.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
return( mean(glm.pred!=data.test$default) )
}
set.seed(2)
n.obs = nrow(Default)
train2 = sample(n.obs, round(n.obs/2), replace=F)
b.fn(Default, train2)
library(ISLR)
attach(Default)
# (c)
b.fn = function(data, index){
data.train = data[index, ]
data.test = data[-index, ]
glm.fit = glm(default~income+balance, data=data.train, family=binomial)
glm.prob = predict(glm.fit, newdata=data.test, type='response')
glm.pred = rep('No', nrow(data.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
return( mean(glm.pred!=data.test$default) )
}
set.seed(2)
n.obs = nrow(Default)
train2 = sample(n.obs, round(n.obs/2), replace=F)
b.fn(Default, train2)
set.seed(1)
n.obs = nrow(Default)
train = sample(n.obs, round(n.obs/2), replace=F)
Default.train = Default[train, ]
Default.test = Default[-train, ]
glm.fit = glm(default~income+balance, data=Default.train, family=binomial)
glm.prob = predict(glm.fit, newdata=Default.test, type='response')
glm.pred = rep('No', nrow(Default.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
table(glm.pred, Default.test$default)
mean(glm.pred!=Default.test$default)
set.seed(3)
train.3 = sample(n.obs, round(n.obs/2), replace=F)
test.err.3 = b.fn(Default, train.3)
test.err.3
library(ISLR)
attach(Default)
# (a)
glm.fit = glm(default~income+balance, data=Default, family=binomial)
# (b)
set.seed(1)
n.obs = nrow(Default)
train = sample(n.obs, round(n.obs/2), replace=F)
Default.train = Default[train, ]
Default.test = Default[-train, ]
glm.fit = glm(default~income+balance, data=Default.train, family=binomial)
glm.prob = predict(glm.fit, newdata=Default.test, type='response')
glm.pred = rep('No', nrow(Default.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
test.err.1 = mean(glm.pred!=Default.test$default)
# (c)
b.fn = function(data, index){
data.train = data[index, ]
data.test = data[-index, ]
glm.fit = glm(default~income+balance, data=data.train, family=binomial)
glm.prob = predict(glm.fit, newdata=data.test, type='response')
glm.pred = rep('No', nrow(data.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
return( mean(glm.pred!=data.test$default) )
}
set.seed(2)
n.obs = nrow(Default)
train.2 = sample(n.obs, round(n.obs/2), replace=F)
test.err.2 = b.fn(Default, train.2)
set.seed(3)
train.3 = sample(n.obs, round(n.obs/2), replace=F)
test.err.3 = b.fn(Default, train.3)
contrasts(Default$student)
c.fn = function(data, index){
data.train = data[index, ]
data.test = data[-index, ]
glm.fit = glm(default~income+balance+student, data=data.train, family=binomial)
glm.prob = predict(glm.fit, newdata=data.test, type='response')
glm.pred = rep('No', nrow(data.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
return( mean(glm.pred!=data.test$default) )
}
test.err = c.fn(Default, train.1)
test.err = c.fn(Default, train)
test.err
test.err.1 = c.fn(Default, train)
test.err.2 = c.fn(Default, train.2)
test.err.3 = c.fn(Default, train.3)
# (a)
glm.fit = glm(default~income+balance, data=Default, family=binomial)
# (b)
set.seed(1)
n.obs = nrow(Default)
train = sample(n.obs, round(n.obs/2), replace=F)
Default.train = Default[train, ]
Default.test = Default[-train, ]
glm.fit = glm(default~income+balance, data=Default.train, family=binomial)
glm.prob = predict(glm.fit, newdata=Default.test, type='response')
glm.pred = rep('No', nrow(Default.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
test.err.1 = mean(glm.pred!=Default.test$default)
# (c)
b.fn = function(data, index){
data.train = data[index, ]
data.test = data[-index, ]
glm.fit = glm(default~income+balance, data=data.train, family=binomial)
glm.prob = predict(glm.fit, newdata=data.test, type='response')
glm.pred = rep('No', nrow(data.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
return( mean(glm.pred!=data.test$default) )
}
set.seed(2)
n.obs = nrow(Default)
train.2 = sample(n.obs, round(n.obs/2), replace=F)
test.err.2 = b.fn(Default, train.2)
set.seed(3)
train.3 = sample(n.obs, round(n.obs/2), replace=F)
test.err.3 = b.fn(Default, train.3)
# (d)
c.fn = function(data, index){
data.train = data[index, ]
data.test = data[-index, ]
glm.fit = glm(default~income+balance+student, data=data.train, family=binomial)
glm.prob = predict(glm.fit, newdata=data.test, type='response')
glm.pred = rep('No', nrow(data.test))
glm.pred[ glm.prob>=0.5 ] = 'Yes'
return( mean(glm.pred!=data.test$default) )
}
test.err.1 = c.fn(Default, train)
test.err.2 = c.fn(Default, train.2)
test.err.3 = c.fn(Default, train.3)
glm.fit = glm(default~income+balance, data=Default, family=binomial)
summary(glm.fit)
boot.fn = function(data, index){
glm.fit = glm(default~income+balance, data=data, subset=index, family=binomial)
return( coef(glm.fit) )
}
library(boot)
?boot
boot(Default, boot.fn, R=1000)
glm.fit = glm(default~income+balance, data=Default, family=binomial)
coef(glm.fit)
glm.fit = glm(default~income+balance, data=Default, family=binomial)
coef(glm.fit)[-1]
# (b)
boot.fn = function(data, index){
glm.fit = glm(default~income+balance, data=data, subset=index, family=binomial)
return( coef(glm.fit)[-1] )
}
# (c)
boot(Default, boot.fn, R=1000)
library(ISLR)
attach(Weekly)
# (a)
glm.fit = glm(Direction~Lag1+Lag2, data=Weekly, family=binomial)
# ************* Quetion 7 *************
library(ISLR)
attach(Weekly)
# (a)
glm.fit = glm(Direction~Lag1+Lag2, data=Weekly, family=binomial)
glm.fit = glm(Direction~Lag1+Lag2, data=Weekly[-1, ], family=binomial)
glm.prob = predict(glm.fit, newdata=Weekly[1, ], type='response')[1]
glm.pred = if (glm.prob >= 0.5) 'Yes' else 'No'
predict(glm.fit, newdata=Weekly[1, ], type='response')
glm.prob = predict(glm.fit, newdata=Weekly[1, ], type='response')[1]
glm.prob
glm.prob = predict(glm.fit, newdata=Weekly[1, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Yes' else 'No'
typeof(glm.prob)
class(glm.prob)
glm.prob = predict(glm.fit, newdata=Weekly[1, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Yes' else 'No'
glm.prob = predict(glm.fit, newdata=Weekly[1:2, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Yes' else 'No'
glm.prob = predict(glm.fit, newdata=Weekly[1, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Yes' else 'No'
Weekly[1, ]$Direction
contrasts(Direction)
glm.prob = predict(glm.fit, newdata=Weekly[1, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Up' else 'Down'
n.obs = nrow(Weekly)
store = rep(NA, n.obs)
for (i in 1:n.obs){
glm.fit = glm(Direction~Lag1+Lag2, data=Weekly[-i, ], family=binomial)
glm.prob = predict(glm.fit, newdata=Weekly[i, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Up' else 'Down'
store[i] = (glm.pred == Weekly$Direction[i])
}
store
n.obs = nrow(Weekly)
store = rep(NA, n.obs)
for (i in 1:n.obs){
glm.fit = glm(Direction~Lag1+Lag2, data=Weekly[-i, ], family=binomial)
glm.prob = predict(glm.fit, newdata=Weekly[i, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Up' else 'Down'
store[i] = (glm.pred == Weekly$Direction[i]) * 1
}
mean(store)
glm.fit = glm(Direction~Lag1+Lag2, data=Weekly, family=binomial)
summary(glm.fit)
n.obs = nrow(Weekly)
store = rep(NA, n.obs)
for (i in 1:n.obs){
glm.fit = glm(Direction~Lag1+Lag2, data=Weekly[-i, ], family=binomial)
glm.prob = predict(glm.fit, newdata=Weekly[i, ], type='response')
glm.pred = if (glm.prob >= 0.5) 'Up' else 'Down'
store[i] = (glm.pred != Weekly$Direction[i]) * 1
}
mean(store)
# ************* Quetion 6 *************
library(boot)
library(ISLR)
attach(Default)
# (a)
glm.fit = glm(default~income+balance, data=Default, family=binomial)
summary(glm.fit)
# S.E. for income: 4.985e-06
# S.E. for balance: 2.274e-04
# (b)
boot.fn = function(data, index){
glm.fit = glm(default~income+balance, data=data, subset=index, family=binomial)
return( coef(glm.fit)[-1] )
}
# (c)
set.seed(1)
boot(Default, boot.fn, R=1000)
plot(x, y)
# (a)
set.seed(1)
y = rnorm(100)
x = rnorm(100)
y = x - 2*x^2 + rnorm(100)
# n = 100, p = 2
# the equation is: y = x - 2 * X^2 + eps
# (b)
plot(x, y)
df = data.frame(c(X, Y))
df = data.frame(c(x, y))
df = data.frame(x, y)
n.obs = nrow(df)
df = data.frame(x, y)
n.obs = nrow(df)
cv.err = rep(NA, 5)
set.seed(1)
for (i in 1:5) {
glm.fit = glm(y~poly(x, i, raw=T), data=df)
cv.err[i] = cv.glm(df, glm.fit, K=n.obs)$delta[1]
}
cv.err
set.seed(2)
for (i in 1:5) {
glm.fit = glm(y~poly(x, i, raw=T), data=df)
cv.err[i] = cv.glm(df, glm.fit, K=n.obs)$delta[1]
}
cv.err
glm.fit = glm(y~x, data=df)
a = summary(glm.fit)
names(a)
a$coefficients
a$coefficients[, 2]
sig = rep(NA, 5)
for (i in 1:5){
glm.fit = glm(y~x, data=df)
print( summary(glm.fit)$coefficients[-1, 4] )
}
# (f)
sig = rep(NA, 5)
for (i in 1:5){
glm.fit = glm(y~poly(x, i, raw=T), data=df)
print( summary(glm.fit)$coefficients[-1, 4] )
}
sig = rep(NA, 5)
for (i in 1:5){
glm.fit = glm(y~poly(x, i, raw=T), data=df)
print( summary(glm.fit)$coefficients[-1, 4] )
print('\n')
}
sig = rep(NA, 5)
for (i in 1:5){
glm.fit = glm(y~poly(x, i, raw=T), data=df)
print( summary(glm.fit)$coefficients[-1, 4] )
print('/n')
}
# (f)
sig = rep(NA, 5)
for (i in 1:5){
glm.fit = glm(y~poly(x, i, raw=T), data=df)
print( paste0('degree = ', i) )
print( summary(glm.fit)$coefficients[-1, 4] )
}
library(MASS)
attach(Boston)
?Boston
mean(medv)
sigma = sd(medv)/length(medv)
mu = mean(medv)
sigma
sigma = sd(medv)/sqrt( length(medv) )
sigma
library(boot)
boot.fn = function(data, index){
return( mean( data$medv[index] ) )
}
boot(Boston, boot.fn, R=1000)
qnorm(0.95)
qnorm(0.975)
a = boot(Boston, boot.fn, R=1000)
names(a)
a$statistic()
a$statistic
a
names(a)
a$t
a$R
a$weights
a$strata
a$stype
a$t0
a$call
summary(a)
summary(a)$bootSE
summary(a)
summary(a)$bootSE
sd(a$t)
a
set.seed(1)
boot.result = boot(Boston, boot.fn, R=1000)
boot.result
low = mu - qnorm(0.975) * sd(boot.result$t)
up = mu + qnorm(0.975) * sd(boot.result$t)
low
up
t.test(Boston$medv)
med = median(medv)
boot.fn = function(data, index){
return( median(data$medv[index]) )
}
set.seed(1)
boot.result = boot(Boston, boot.fn, R=1000)
boot.result
q.10 = quantile(medv), 0.1
q.10 = quantile(medv, 0.1)
q.10
boot.fn = function(data, index){
return( quantile(data$medv[index], 0.1) )
}
set.seed(1)
boot.result = boot(Boston, boot.fn, R=1000)
boot.result
